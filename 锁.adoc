= 锁

== 概述

锁是控制多个线程对共享资源进行访问的工具。通常，锁提供了对共享资源的独占访问。一次只能有一个线程获得锁，对共享资源的所有访问都需要首先获得锁。不过，某些锁可能允许对共享资源并发访问，如 ReadWriteLock。

使用synchronized方法可以访问与每个对象关联的隐式监视器锁，但却强制所有锁获取和释放均要出现在块结构中.当获取多个锁时，它们必须以相反的顺序释放，并且所有锁必须在获取它们的相同词法范围内释放。

虽然synchronized的范围机制使得使用监视器锁编程方便了很多，而且还帮助避免了很多涉及到锁的常见编程错误，但有时也需要以更为灵活的方式使用锁.例如，某些并发访问数据的算法要求使用 "hand-over-hand" 或 "chain locking"：获取节点 A 的锁，然后再获取节点 B 的锁，然后释放 A 并获取 C，然后释放 B 并获取 D，依此类推。Lock 接口的实现允许锁在不同的作用范围内获取和释放，并允许以任何顺序获取和释放多个锁.

随着灵活性的增加,也带来了一些困扰,我们不能像synchronized那样自动获取和释放锁.必须使用下面的结构来组织代码:
[source,java]
----
     Lock l = ...; 
     l.lock();
     try {
         // 访问被保护的资源
     } finally {
         l.unlock();
     }
----

Lock提供了很多synchronized所没有的功能，例如获tryLock()、lockInterruptibly(除非当前线程被中断，否则获取锁定。),tryLock(long, TimeUnit)。

Lock 类还提供了与隐式监视器锁完全不同的行为和语义，如保证排序、非重入用法或死锁检测。

注意，Lock 实例只是普通的对象，其本身可以在 synchronized 语句中作为目标使用。

NOTE: 获取锁的三种形式（** 可中断，不可中断和定时 **）可能在性能特征，顺序保证或其他实现方面有所不同。


== Lock 接口
[source,java]
----
public interface Lock {

	void lock(); <1>
	void lockInterruptibly() throws InterruptedException; <2>
	boolean tryLock(); <3>
	boolean tryLock(long time, TimeUnit unit) throws InterruptedException; <4>
	void unlock(); <5>
	Condition newCondition(); <6>
}
----

<1> 获取锁。如果锁不可用，出于线程调度目的，将禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态。

<2> 如果当前线程未被中断，则获取锁。如果锁可用，则获取锁，并立即返回。如果锁不可用，出于线程调度目的，将禁用当前线程，该线程将一直处于休眠状态,如果发生下面两种情况,休眠将被中断: (A).当前线程获取到了锁 (B).当前线程被中断.如果线程在调用该方法的时候,设置了线程中断状态或者在调用该方法的过程中被中断,将抛出InterruptedException并清除当前线程的中断状态。
	
<3> 如果锁可用，则获取锁，并立即返回值 true。如果锁不可用，则此方法将立即返回值 false。

<4> 如果获得了锁，则返回 true；如果在获取锁前超过了等待时间，则返回 false ,该方法支持线程中断,参考 <2> .

<5> 释放锁.

<6> 返回绑定到此 Lock 实例的新 Condition 实例。


== 读写锁

ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写锁是独占的。

所有ReadWriteLock实现都必须保证writeLock操作的内存同步效果（如Lock接口中所指定）对相关的readLock也有效。也就是说，成功获取读锁的线程会看到先前写锁的更新。

与互斥锁相比，读-写锁允许对共享数据进行更高级别的并发访问。虽然一次只有一个线程（writer线程）可以修改共享数据，但在许多情况下，任何数量的线程可以同时读取共享数据（reader 线程）。从理论上讲，与互斥锁相比，使用读-写锁将带来更大的性能提高。在实践中，只有在多处理器上并且只在访问模式适用于共享数据时，才能完全实现并发性增强。

