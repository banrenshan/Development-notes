如果@Qualifier注解中没有指定限定名称,spring会指定bean的id作为限定名称.需要注意的是,@Autowired注解是先匹配所有的类型,然后再根据
@Qualifier选定具体的bean的,不要以为我们可以直接通过限定名就可以自动注入.

@Qualifier注解也可以使用在集合上,这种情况下,所有匹配的bean会被注入.

[NOTE]
====
注入点上的@Qualifier注解不是必须的,spring在注入的时候如果发现有很多匹配项,会使用参数的名称作为限定值.

JSR-250 @Resource注解是完全根据限定名来匹配的,不管注入的类型是否和需要的一致.

@Autowired适用于字段，构造函数和多参数方法，允许在参数级别缩小限定范围。 相比之下，@ Resource仅支持field和具有单个参数的setter方法。 因此，如果注射目标是构造函数或多参数方法，则应该使用@Qualifier。
====

您可以创建自定义限定符注解。 如以下示例所示：
[source,java]
----
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Genre {

    String value();
}
----

下面的代码告诉你如何使用:
[source,java]
----
public class MovieRecommender {

    @Autowired
    @Genre("Action")
    private MovieCatalog actionCatalog;

    private MovieCatalog comedyCatalog;

    @Autowired
    public void setComedyCatalog(@Genre("Comedy") MovieCatalog comedyCatalog) {
        this.comedyCatalog = comedyCatalog;
    }
}
----

==== 使用泛型作为自动装配限定符
除了@Qualifier注释之外，您还可以使用Java泛型类型作为隐式的限定形式。 例如，假设您具有以下配置：
[source,java]
----
@Configuration
public class MyConfiguration {

    @Bean
    public StringStore stringStore() {
        return new StringStore();
    }

    @Bean
    public IntegerStore integerStore() {
        return new IntegerStore();
    }
}
----

假设前面的bean实现了一个通用接口（即Store<String>和Store<Integer>），您可以@Autowire Store接口，并将泛型用作限定符，如下例所示：
[source,java]
----
@Autowired
private Store<String> s1; // <String> qualifier, injects the stringStore bean

@Autowired
private Store<Integer> s2; // <Integer> qualifier, injects the integerStore bean
----

泛型限定符也适用于自动装配列表，Map实例和数组。 以下示例自动装配通用List：
[source,java]
----
// Inject all Store beans as long as they have an <Integer> generic
// Store<String> beans will not appear in this list
@Autowired
private List<Store<Integer>> s;
----

==== 使用CustomAutowireConfigurer

CustomAutowireConfigurer是一个BeanFactoryPostProcessor，它允许您注册自己的自定义限定符注释类型，即使它们没有使用Spring的@Qualifier注释进行注释。 以下示例显示如何使用CustomAutowireConfigurer：
[source,java]
----
<bean id="customAutowireConfigurer"
        class="org.springframework.beans.factory.annotation.CustomAutowireConfigurer">
    <property name="customQualifierTypes">
        <set>
            <value>example.CustomQualifier</value>
        </set>
    </property>
</bean>
----
AutowireCandidateResolver通过以下方式确定autowire候选者：
. 每个bean定义的autowire-candidate值
. <beans />元素上可用的任何default-autowire候选模式
. 存在@Qualifier注释以及使用CustomAutowireConfigurer注册的任何自定义注释

当多个bean有资格作为autowire候选者时，“primary”的确定如下：如果候选者中只有一个bean定义的primary属性设置为true，则选择它。

==== 使用@Resource注解

@Resource采用name属性。 默认情况下，Spring将该值解释为要注入的bean名称。 换句话说，它遵循按名称语义，如以下示例所示：
[source,java]
----
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Resource(name="myMovieFinder")
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
----
如果未明确指定名称，则默认名称是从字段名称或setter方法派生的。 如果是字段，则采用属性名称。 在setter方法的情况下，它采用bean属性名称。

@Resource先根据名称匹配,匹配不到再根据类型选择

==== 使用@PostConstruct和@PreDestroy

CommonAnnotationBeanPostProcessor不仅识别@Resource注释，还识别JSR-250生命周期注释：javax.annotation.PostConstruct和javax.annotation.PreDestroy。
[source,java]
----
public class CachingMovieLister {

    @PostConstruct
    public void populateMovieCache() {
        // populates the movie cache upon initialization...
    }

    @PreDestroy
    public void clearMovieCache() {
        // clears the movie cache upon destruction...
    }
}
----

NOTE: 与@Resource一样，@ PostConstruct和@PreDestroy注释类型是JDK 6到8的标准Java库的一部分。但是，整个javax.annotation包再JDK 9中的核心Java模块分离，最终在JDK 11中删除 如果需要，现在需要通过Maven Central获取javax.annotation-api工件，只需像任何其他库一样添加到应用程序的类路径中。


=== 类路径扫描和组件管理

==== @Component

@Component 是任何Spring管理组件的通用构造型。 @Repository ， @Service 和 @Controller 是 @Component的特例化,作用是一样的,之所以这么做,是为了更好的区分组件.


==== 使用元注解和注解组合

Spring提供的许多注解都可以在您自己的代码中用作元注解。 元注解是可以应用于另一个注解的注解。 例如，前面提到的@Service注解是使用@Component进行元注解的，如下例所示：
[source,java]
----
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Service {

    // ....
}
----

您还可以创建“组合注释”。 例如，Spring MVC的@RestController注释由@Controller和@ResponseBody组成。

此外，组合注解可以选择从元注解重新声明属性以允许自定义。 当您只想公开元注解属性的子集时，这可能特别有用。 例如，Spring的@SessionScope注释将范围名称硬编码到session，但仍允许自定义proxyMode。 以下清单显示了SessionScope批注的定义：
[source,java]
----
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Scope(WebApplicationContext.SCOPE_SESSION)
public @interface SessionScope {

    /**
     * Alias for {@link Scope#proxyMode}.
     * <p>Defaults to {@link ScopedProxyMode#TARGET_CLASS}.
     */
    @AliasFor(annotation = Scope.class)
    ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;

}
----

==== 自动检测类并注册成Bean

spring可以自动检测被这些注解批注的类,并注册成容器管理的bean,例如:
[source,java]
----
@Service
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
----

[source,java]
----
@Repository
public class JpaMovieFinder implements MovieFinder {
    // implementation elided for clarity
}
----

要自动检测这些类并注册相应的bean，需要将@ComponentScan添加到@Configuration类，其中basePackages属性指定两个类(上述)的公共父包。 （或者是父包的逗号或分号或空格分隔列表。）
[source,java]
----
@Configuration
@ComponentScan(basePackages = "org.example")
public class AppConfig  {
    ...
}
----

此外，使用component-scan元素时，将隐式包含AutowiredAnnotationBeanPostProcessor和CommonAnnotationBeanPostProcessor。

==== 使用过滤器自定义扫描

默认情况下，使用@Component，@ Repository，@ Service，@ Controller注释的类或者基于上面的注解扩展的注解会被扫描然后注册成备案。 但是，您可以通过应用自定义筛选器来修改和扩展此行为。@ComponentScan注释的includeFilters或excludeFilters参数来包含和排除. 每个filter元素都需要type和expression属性。 下表介绍了筛选选项：

|===
|类型|示例表达式|描述

|annotation (default)|org.example.SomeAnnotation|出现在目标类上的注解
|assignable|org.example.SomeClass|
|aspectj|org.example..*Service+|
|regex|org\.example\.Default.*|
|custom|org.example.MyTypeFilter|

|===

[source,java]
----
@Configuration
@ComponentScan(basePackages = "org.example",
        includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"),
        excludeFilters = @Filter(Repository.class))
public class AppConfig {
    ...
}
----

==== 在组件中定义Bean元数据

Spring组件还可以向容器提供bean定义元数据。 您可以使用@Bean注释来执行此操作。 以下示例显示了如何执行此操作：
[source,java]
----
@Component
public class FactoryMethodComponent {

    @Bean
    @Qualifier("public")
    public TestBean publicInstance() {
        return new TestBean("publicInstance");
    }

    public void doWork() {
        // Component method implementation omitted
    }
}
----

[source,java]
----
@Component
public class FactoryMethodComponent {

    private static int i;

    @Bean
    @Qualifier("public")
    public TestBean publicInstance() {
        return new TestBean("publicInstance");
    }

    // use of a custom qualifier and autowiring of method parameters
    @Bean
    protected TestBean protectedInstance(
            @Qualifier("public") TestBean spouse,
            @Value("#{privateInstance.age}") String country) {
        TestBean tb = new TestBean("protectedInstance", 1);
        tb.setSpouse(spouse);
        tb.setCountry(country);
        return tb;
    }

    @Bean
    private TestBean privateInstance() {
        return new TestBean("privateInstance", i++);
    }

    @Bean
    @RequestScope
    public TestBean requestScopedInstance() {
        return new TestBean("requestScopedInstance", 3);
    }
}
----

==== 被扫描到的备案的命名规范

当组件被扫描到后,注册到bean容器中的名称有BeanNameGenerator 策略提供支持,默认情况下,@Component, @Repository, @Service和 @Controller注解都受此规范约束.我们通过列子来做说明:
[source,java]
----
@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}
----
生成的bean名称是类名名称,但是首字母小写,例如上面的类生成的bean名称是movieFinderImpl

我们可以在注解上自定义该名称,例如:
[source,java]
----
@Service("myMovieLister")
public class SimpleMovieLister {
    // ...
}
----

[NOTE]
====
如果您不想依赖默认的bean命名策略，则可以提供自定义bean命名策略。 首先，实现BeanNameGenerator接口，并确保包含默认的无参数构造函数。 然后，在配置扫描程序时提供完全限定的类名，如以下示例注释和bean定义所示：

[source,java]
----
@Configuration
@ComponentScan(basePackages = "org.example", nameGenerator = MyNameGenerator.class)
public class AppConfig {
    ...
}
----
====

需要注意的是,如果两个类的名称相同,spring容器在注入的时候就会出错,你可以通过注解分别给两个类指定不同的bean名称来避免

==== 给自动扫描的注解指定scope

与Spring管理的组件一样，自动检测组件的默认和最常见的范围是 `singleton`。 但是，有时您需要一个可由@Scope注解指定的不同范围。 您可以在注释中提供范围的名称，如以下示例所示：
[source,java]
----
@Scope("prototype")
@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}
----

[NOTE]
====
要为范围解析提供自定义策略而不是依赖基于注释的方法，可以实现ScopeMetadataResolver接口。 请确保包含默认的无参数构造函数。 然后，您可以在配置扫描程序时提供完全限定的类名，因为以下注释和bean定义示例显示：
[source,java]
----
@Configuration
@ComponentScan(basePackages = "org.example", scopeResolver = MyScopeResolver.class)
public class AppConfig {
    ...
}
----
====

使用某些非单例作用域时，可能需要为作用域对象生成代理。 component-scan元素上提供了scoped-proxy属性。 三个可能的值是：no，interfaces和targetClass。 例如，以下配置是标准的JDK动态代理：
[source,java]
----
@Configuration
@ComponentScan(basePackages = "org.example", scopedProxy = ScopedProxyMode.INTERFACES)
public class AppConfig {
    ...
}
----

====  给自动扫描的bean提供Qualifier

[source,java]
----
@Component
@Qualifier("Action")
public class ActionMovieCatalog implements MovieCatalog {
    // ...
}
@Component
@Genre("Action")
public class ActionMovieCatalog implements MovieCatalog {
    // ...
}
@Component
@Offline
public class CachingMovieCatalog implements MovieCatalog {
    // ...
}
----

==== 生产候选组价的索引

虽然类路径扫描速度非常快，但可以通过在编译时创建候选的静态列表来提高大型应用程序的启动性能。 在此模式下，所有作为组件扫描目标的模块都必须使用此机制。

使用该特性,需要添加依赖:

.maven
[source,xml]
----
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context-indexer</artifactId>
        <version>5.1.9.RELEASE</version>
        <optional>true</optional>
    </dependency>
</dependencies>
----

.gradle
[source,shell]
----
dependencies {
    annotationProcessor "org.springframework:spring-context-indexer:5.1.9.RELEASE"
}
----


该过程生成的索引文件,包含在jar文件中的META-INF/spring.components文件。

NOTE:在类路径上找到META-INF/spring.components时，将自动启用索引。 如果索引部分可用于某些库（或用例）但无法为整个应用程序构建，则可以通过将spring.index.ignore设置true,回退到常规类路径.

=== 使用JSR 330标准注解

要使用这些注解,需要先引入jar包:
[source,java]
----
<dependency>
    <groupId>javax.inject</groupId>
    <artifactId>javax.inject</artifactId>
    <version>1</version>
</dependency>
----

==== 使用@Inject和@Named进行依赖注入

除了使用@Autowired,你还可以使用@javax.inject.Inject进行依赖注入,例如:
[source,java]
----
import javax.inject.Inject;

public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    public void listMovies() {
        this.movieFinder.findMovies(...);
        ...
    }
}
----

你可以使用@Inject在字段级别,方法级别,构造参数级别.此外，您可以将注入点声明为Provider，允许按需访问较短范围的bean或通过Provider.get（）调用对其他bean的延迟访问。 以下示例提供了上述示例的变体：
[source,java]
----
import javax.inject.Inject;
import javax.inject.Provider;

public class SimpleMovieLister {

    private Provider<MovieFinder> movieFinder;

    @Inject
    public void setMovieFinder(Provider<MovieFinder> movieFinder) {
        this.movieFinder = movieFinder;
    }

    public void listMovies() {
        this.movieFinder.get().findMovies(...);
        ...
    }
}
----

如果你想为注入的依赖指定限定名称,你应该使用@Name注解,例如:
[source,java]
----
import javax.inject.Inject;
import javax.inject.Named;

public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(@Named("main") MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
----

与@Autowired一样，@ Inject也可以与java.util.Optional或@Nullable一起使用。 这在这里更适用，因为@Inject没有必需的属性。 以下一对示例显示了如何使用@Inject和@Nullable：
[source,java]
----
public class SimpleMovieLister {

    @Inject
    public void setMovieFinder(Optional<MovieFinder> movieFinder) {
        ...
    }
}
----

[source,java]
----
public class SimpleMovieLister {

    @Inject
    public void setMovieFinder(@Nullable MovieFinder movieFinder) {
        ...
    }
}
----

==== @Named and @ManagedBean:等价于@Component注解
[source,java]
----
import javax.inject.Inject;
import javax.inject.Named;

@Named("movieListener")  // @ManagedBean("movieListener") could be used as well
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
----

在不指定组件名称的情况下使用@Component是很常见的。 @Named可以以类似的方式使用，如下例所示：
[source,java]
----
import javax.inject.Inject;
import javax.inject.Named;

@Named
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
----

使用@Named或@ManagedBean时，可以使用与使用Spring注释时完全相同的方式使用组件扫描，如以下示例所示：
[source,java]
----
@Configuration
@ComponentScan(basePackages = "org.example")
public class AppConfig  {
    ...
}
----

==== JSR-330注解的局限性

|===
|spring注解|jdk注解|局限

|@Autowired|@Inject|@Inject注解没有required属性,可以通过使用java8的Optional代替
|@Component|@Named / @ManagedBean|不能用于注解组合
|@Scope("singleton")|@Singleton|JSR303默认的scope是prototype,为了与spring保持一致,spring应用中默认是单例
|@Qualifier|@Qualifier / @Named|javax.inject.Qualifier只是构建自定义限定符的元注释。 具体字符串限定符（如Spring的带有值的@Qualifier）可以通过javax.inject.Named关联。
|@Value|-|
|@Required|-|
|@Lazy|-|
|ObjectFactory|Provider|javax.inject.Provider是Spring的ObjectFactory的直接替代品，只有更短的get（）方法名称。 它也可以与Spring的@Autowired结合使用，也可以与非注释的构造函数和setter方法结合使用。

|===

=== 基于java代码的容器配置

==== @Bean和@Configuration

@Bean注解的方法主要用来构建spring容器管理的bean,可以在该方法内配置化bean.被bean注释的方法所在的类可以被@Component注解,但是一般是被@Configuration注解.

@Configuration注解来用来表明该类是配置类,此外，@Configuration类允许通过调用同一个类中的其他@Bean方法来定义bean间依赖关系。下面是一个简单的例子:
[source,java]
----
@Configuration
public class AppConfig {

    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}
----

.Full @Configuration vs “lite” @Bean mode?
****
如果@Bean注解的方法所在类没有被@Configuration注解,被称为 `lite模式`, 例如声明在@Component注解的类.这种模式下,不能使用@Bean注解的方法作为依赖

在常见的场景中，@Bean方法将在@Configuration类中声明，确保始终使用“full”模式，并因此将交叉方法引用重定向到容器的生命周期管理。 这可以防止通过常规Java调用意外地调用相同的@Bean方法，这有助于减少在“lite”模式下操作时难以跟踪的细微错误。
****

==== 使用AnnotationConfigApplicationContext实例化容器

这个多功能的ApplicationContext实现不仅能够接受@Configuration类作为输入，还能接受使用JSR-330元数据注解和@Component注解的类。

当@Configuration类作为输入提供时，@ Consfiguration类本身被注册为bean定义，并且类中所有声明的@Bean方法也被注册为bean定义。

当提供@Component和JSR-330类时，它们被注册为bean定义，并且假设该类的实例需要依赖注入。


===== 简单的使用
[source,java]
----
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
----

如前所述，AnnotationConfigApplicationContext不限于使用@Configuration类。 任何@Component或JSR-330带注释的类都可以作为输入提供给构造函数，如以下示例所示：
[source,java]
----
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
----

===== 使用register(Class<?>…​)构建容器

您可以使用no-arg构造函数实例化AnnotationConfigApplicationContext，然后使用register（）方法对其进行配置。 在以编程方式构建AnnotationConfigApplicationContext时，此方法特别有用。 以下示例显示了如何执行此操作：
[source,java]
----
public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.register(AppConfig.class, OtherConfig.class);
    ctx.register(AdditionalConfig.class);
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
----

===== 使用scan(String…​)启用组件扫描
[source,java]
----
public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.scan("com.acme");
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
}
----

===== 使用AnnotationConfigWebApplicationContext开启web支持
AnnotationConfigWebApplicationContext提供了对web的支持,配置Spring ContextLoaderListener servlet侦听器，Spring MVC DispatcherServlet等时，可以使用此实现。 以下web.xml代码段配置典型的Spring MVC Web应用程序（请注意contextClass context-param和init-param的使用）：
[source,xml]
----
<web-app>
    <!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
        instead of the default XmlWebApplicationContext -->
    <context-param>
        <param-name>contextClass</param-name>
        <param-value>
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        </param-value>
    </context-param>

    <!-- Configuration locations must consist of one or more comma- or space-delimited
        fully-qualified @Configuration classes. Fully-qualified packages may also be
        specified for component-scanning -->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>com.acme.AppConfig</param-value>
    </context-param>

    <!-- Bootstrap the root application context as usual using ContextLoaderListener -->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>

    <!-- Declare a Spring MVC DispatcherServlet as usual -->
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
            instead of the default XmlWebApplicationContext -->
        <init-param>
            <param-name>contextClass</param-name>
            <param-value>
                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
            </param-value>
        </init-param>
        <!-- Again, config locations must consist of one or more comma- or space-delimited
            and fully-qualified @Configuration classes -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>com.acme.web.MvcConfig</param-value>
        </init-param>
    </servlet>

    <!-- map all requests for /app/* to the dispatcher servlet -->
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/app/*</url-pattern>
    </servlet-mapping>
</web-app>
----

==== 使用@Bean注解

===== 声明bean

要声明bean，可以使用@Bean批注对方法进行批注。 方法的返回值是注册bean的类型。 默认情况下，bean名称与方法名称相同。 以下示例显示了@Bean方法声明：
[source,java]
----
@Configuration
public class AppConfig {

    @Bean
    public TransferServiceImpl transferService() {
        return new TransferServiceImpl();
    }
}
----

===== bean依赖

@ Bean-annotated方法可以有任意数量的参数来描述构建该bean所需的依赖项。 例如，如果我们的TransferService需要AccountRepository，我们可以使用方法参数来实现该依赖关系，如以下示例所示：
[source,java]
----
@Configuration
public class AppConfig {

    @Bean
    public TransferService transferService(AccountRepository accountRepository) {
        return new TransferServiceImpl(accountRepository);
    }
}
----


===== 生命周期回调

[source,java]
----
public class BeanOne {

    public void init() {
        // initialization logic
    }
}

public class BeanTwo {

    public void cleanup() {
        // destruction logic
    }
}

@Configuration
public class AppConfig {

    @Bean(initMethod = "init")
    public BeanOne beanOne() {
        return new BeanOne();
    }

    @Bean(destroyMethod = "cleanup")
    public BeanTwo beanTwo() {
        return new BeanTwo();
    }
}

----

对于前面注释中上面示例中的BeanOne，在构造期间直接调用init（）方法同样有效，如下例所示：
[source,java]
----
@Configuration
public class AppConfig {

    @Bean
    public BeanOne beanOne() {
        BeanOne beanOne = new BeanOne();
        beanOne.init();
        return beanOne;
    }

    // ...
}
----

===== 指定bean的scope

默认范围是单例，但您可以使用@Scope批注覆盖它，如以下示例所示：
[source,java]
----
@Configuration
public class MyConfiguration {

    @Bean
    @Scope("prototype")
    public Encryptor encryptor() {
        // ...
    }
}
----

使用@Scope上的proxyMode属性可以设置代理模式。 默认值为无代理（ScopedProxyMode.NO），但您可以指定ScopedProxyMode.TARGET_CLASS或ScopedProxyMode.INTERFACES。

===== 自定义bean的名称

默认情况下，配置类使用@Bean方法的名称作为结果bean的名称。 但是，可以使用name属性覆盖此功能，如以下示例所示：
[source,java]
----
@Configuration
public class AppConfig {

    @Bean(name = "myThing")
    public Thing thing() {
        return new Thing();
    }
}
----

===== bean别名
正如Naming Beans中所讨论的，有时需要为单个bean提供多个名称，也称为bean别名。 @Bean批注的name属性为此接受String数组。 以下示例显示如何为bean设置多个别名：
[source,java]
----
@Configuration
public class AppConfig {

    @Bean({"dataSource", "subsystemA-dataSource", "subsystemB-dataSource"})
    public DataSource dataSource() {
        // instantiate, configure and return DataSource bean...
    }
}
----

===== Bean 描述
有时，提供更详细的bean文本描述会很有帮助。 当bean（可能通过JMX）进行监视时，这可能特别有用。
[source,java]
----
@Configuration
public class AppConfig {

    @Bean
    @Description("Provides a basic example of a bean")
    public Thing thing() {
        return new Thing();
    }
}
----

==== 使用@Configuration注解

===== bean依赖
当bean彼此依赖时，表达该依赖关系就像让一个bean方法调用另一个bean一样简单，如下例所示：
[source,java]
----
@Configuration
public class AppConfig {

    @Bean
    public BeanOne beanOne() {
        return new BeanOne(beanTwo());
    }

    @Bean
    public BeanTwo beanTwo() {
        return new BeanTwo();
    }
}
----

===== Lookup Method Injection

Lookup Method Injection是一项很少使用的高级功能,一般用于一个单例bean依赖多例bean.我们来看使用示例:
[source,java]
----
public abstract class CommandManager {
    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}
----

通过使用Java配置，您可以创建CommandManager的子类，其中抽象的createCommand（）方法被覆盖，以便查找新的（原型）命令对象。 以下示例显示了如何执行此操作：
[source,java]
----
@Bean
@Scope("prototype")
public AsyncCommand asyncCommand() {
    AsyncCommand command = new AsyncCommand();
    // inject dependencies here as required
    return command;
}

@Bean
public CommandManager commandManager() {
    // return new anonymous implementation of CommandManager with createCommand()
    // overridden to return a new prototype Command object
    return new CommandManager() {
        protected Command createCommand() {
            return asyncCommand();
        }
    }
}
----

===== 有关基于Java的配置如何在内部工作的更多信息
[source,java]
----
@Configuration
public class AppConfig {

    @Bean
    public ClientService clientService1() {
        ClientServiceImpl clientService = new ClientServiceImpl();
        clientService.setClientDao(clientDao());
        return clientService;
    }

    @Bean
    public ClientService clientService2() {
        ClientServiceImpl clientService = new ClientServiceImpl();
        clientService.setClientDao(clientDao());
        return clientService;
    }

    @Bean
    public ClientDao clientDao() {<1>
        return new ClientDaoImpl();
    }
}
----

<1> 只会被调用一次

==== 配置的组合使用

===== 使用@Import注解

就像在Spring XML文件中使用<import />元素来帮助模块化配置一样，@ Immort注释允许从另一个配置类加载@Bean定义，如下例所示：
[source,java]
----
@Configuration
public class ConfigA {

    @Bean
    public A a() {
        return new A();
    }
}

@Configuration
@Import(ConfigA.class)
public class ConfigB {

    @Bean
    public B b() {
        return new B();
    }
}
----
现在，在实例化上下文时，不需要同时指定ConfigA.class和ConfigB.class，只需要显式提供ConfigB，如下例所示：
[source,java]
----
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);

    // now both beans A and B will be available...
    A a = ctx.getBean(A.class);
    B b = ctx.getBean(B.class);
}
----

NOTE: 从Spring Framework 4.2开始，@ Immort还支持引用常规组件类，类似于AnnotationConfigApplicationContext.register方法。 如果要避免组件扫描，这一点特别有用，可以使用一些配置类作为明确定义所有组件的入口点。

前面的例子有效，但很简单。 在大多数实际情况中，bean跨配置类彼此依赖。 使用XML时，这不是问题，因为不涉及编译器，您可以声明ref =“someBean”。 使用@Configuration类时，Java编译器会对配置模型施加约束，因为对其他bean的引用必须是有效的Java语法。

幸运的是，解决这个问题很简单。 正如我们已经讨论过的，@ Bean方法可以有任意数量的参数来描述bean的依赖关系。 考虑以下更多真实场景，其中包含几个@Configuration类，每个类都依赖于在其他类中声明的bean：
[source,java]
----
@Configuration
public class ServiceConfig {

    @Bean
    public TransferService transferService(AccountRepository accountRepository) {
        return new TransferServiceImpl(accountRepository);
    }
}

@Configuration
public class RepositoryConfig {

    @Bean
    public AccountRepository accountRepository(DataSource dataSource) {
        return new JdbcAccountRepository(dataSource);
    }
}

@Configuration
@Import({ServiceConfig.class, RepositoryConfig.class})
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return new DataSource
    }
}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // everything wires up across configuration classes...
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}
----

还有另一种方法可以达到相同的效果。 请记住，@ Configuration类最终只是容器中的另一个bean：这意味着它们可以利用@Autowired和@Value注入以及与任何其他bean相同的其他功能。如下面的例子:
[source,java]
----
@Configuration
public class ServiceConfig {

    @Autowired
    private AccountRepository accountRepository;

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(accountRepository);
    }
}

@Configuration
public class RepositoryConfig {

    private final DataSource dataSource;

    @Autowired
    public RepositoryConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }
}

@Configuration
@Import({ServiceConfig.class, RepositoryConfig.class})
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return new DataSource
    }
}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // everything wires up across configuration classes...
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}
----

在前面的场景中，使用@Autowired可以很好地工作并提供所需的模块化，但确定声明自动装配的bean定义的确切位置仍然有些模棱两可。 例如，作为一名查看ServiceConfig的开发人员，您如何确切地知道@Autowired AccountRepository bean的声明位置？
[source,java]
----
@Configuration
public class ServiceConfig {

    @Autowired
    private RepositoryConfig repositoryConfig;

    @Bean
    public TransferService transferService() {
        // navigate 'through' the config class to the @Bean method!
        return new TransferServiceImpl(repositoryConfig.accountRepository());
    }
}
----

在前面的情况中，定义AccountRepository是完全明确的。 但是，ServiceConfig现在与RepositoryConfig紧密耦合。 通过使用基于接口的或基于类的抽象@Configuration类，可以在某种程度上减轻这种紧密耦合。 请考虑以下示例：
[source,java]
----
@Configuration
public class ServiceConfig {

    @Autowired
    private RepositoryConfig repositoryConfig;

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(repositoryConfig.accountRepository());
    }
}

@Configuration
public interface RepositoryConfig {

    @Bean
    AccountRepository accountRepository();
}

@Configuration
public class DefaultRepositoryConfig implements RepositoryConfig {

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(...);
    }
}

@Configuration
@Import({ServiceConfig.class, DefaultRepositoryConfig.class})  // import the concrete config!
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return DataSource
    }

}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}
----

===== 有条件地包含@Configuration类或@Bean方法

有的时候，有条件地启用或禁用完整的@Configuration类甚至单个@Bean方法通常很有用。 一个常见的例子是，使用@Profile注释来激活bean。

@Profile注释实际上是通过使用更灵活的注释@Conditional实现的。 @Conditional注释表示在注册@Bean之前应该参考特定org.springframework.context.annotation.Condition的实现。

Condition接口的实现提供了一个返回true或false的matches（...）方法。 例如，以下列表显示了用于@Profile的实际Condition实现：
[source,java]
----
@Override
public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
    if (context.getEnvironment() != null) {
        // Read the @Profile annotation attributes
        MultiValueMap<String, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
        if (attrs != null) {
            for (Object value : attrs.get("value")) {
                if (context.getEnvironment().acceptsProfiles(((String[]) value))) {
                    return true;
                }
            }
            return false;
        }
    }
    return true;
}
----

===== 配置方式混合使用

====== xml为主,兼用@Configuration 配置的类

**将@Configuration类声明为普通的Spring <bean />元素**

请记住，@ Configuration类最终是容器中的bean定义。 在本系列示例中，我们创建一个名为AppConfig的@Configuration类，并将其作为<bean />定义包含在system-test-config.xml中。 由于<context：annotation-config />已打开，容器会识别@Configuration批注并正确处理AppConfig中声明的@Bean方法。
[source,java]
----
@Configuration
public class AppConfig {

    @Autowired
    private DataSource dataSource;

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }

    @Bean
    public TransferService transferService() {
        return new TransferService(accountRepository());
    }
}
----

[source,xml]
----
<beans>
    <!-- enable processing of annotations such as @Autowired and @Configuration -->
    <context:annotation-config/>
    <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>

    <bean class="com.acme.AppConfig"/>

    <bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
</beans>
----

[source,java]
----
public static void main(String[] args) {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:/com/acme/system-test-config.xml");
    TransferService transferService = ctx.getBean(TransferService.class);
    // ...
}
----

**使用<context：component-scan />来获取@Configuration类**

因为@Configuration是使用@Component进行元注释的，所以@Configuration-annotated类自动成为组件扫描的候选者。 使用与前一个示例中描述的相同的方案，我们可以重新定义system-test-config.xml以利用组件扫描。 请注意，在这种情况下，我们不需要显式声明<context：annotation-config />，因为<context：component-scan />启用相同的功能。
[source,xml]
----
<beans>
    <!-- picks up and registers AppConfig as a bean definition -->
    <context:component-scan base-package="com.acme"/>
    <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>

    <bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
</beans>
----

===== @Configuration为主,兼用XML

[source,java]
----
@Configuration
@ImportResource("classpath:/com/acme/properties-config.xml")
public class AppConfig {

    @Value("${jdbc.url}")
    private String url;

    @Value("${jdbc.username}")
    private String username;

    @Value("${jdbc.password}")
    private String password;

    @Bean
    public DataSource dataSource() {
        return new DriverManagerDataSource(url, username, password);
    }
}
----

.properties-config.xml
[source,xml]
----
<beans>
    <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>
</beans>
----

[source,java]
----
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    TransferService transferService = ctx.getBean(TransferService.class);
    // ...
}
----

=== 环境抽象

Environment接口是集成在容器中的抽象，它模拟了应用程序环境的两个关键方面：配置文件和属性。

==== 使用@Profile

@Profile注释允许您指示当一个或多个指定的配置文件处于活动状态时，组件符合注册条件。 使用前面的示例，我们可以重写dataSource配置，如下所示：
[source,java]
----
@Configuration
@Profile("development")
public class StandaloneDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .addScript("classpath:com/bank/config/sql/test-data.sql")
            .build();
    }
}
@Configuration
@Profile("production")
public class JndiDataConfig {

    @Bean(destroyMethod="")
    public DataSource dataSource() throws Exception {
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
    }
}
----

value支持表达式:

. !: A logical “not” of the profile
. &: A logical “and” of the profiles
. |: A logical “or” of the profiles

NOTE: 如果使用@Profile标记@Configuration类，则除非一个或多个指定的配置文件处于活动状态，否则将绕过与该类关联的所有@Bean方法和@Import注释。 如果使用@Profile（{“p1”，“p2”}）标记@Component或@Configuration类，则除非已激活配置文件“p1”或“p2”，否则不会注册或处理该类。 如果给定的配置文件以NOT运算符（！）作为前缀，则仅在配置文件未激活时才注册带注释的元素。 例如，给定@Profile（{“p1”，“！p2”}），如果配置文件“p1”处于活动状态或配置文件“p2”未激活，则会进行注册。

@Profile是一个元注解

[source,java]
----
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Profile("production")
public @interface Production {
}
----

prifle也可以被声明在方法级别:
[source,java]
----
@Configuration
public class AppConfig {

    @Bean("dataSource")
    @Profile("development")
    public DataSource standaloneDataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .addScript("classpath:com/bank/config/sql/test-data.sql")
            .build();
    }

    @Bean("dataSource")
    @Profile("production")
    public DataSource jndiDataSource() throws Exception {
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
    }
}
----

===== 激活Profile

激活配置文件可以通过多种方式完成，但最直接的方法是以编程方式对可通过ApplicationContext提供的Environment API进行操作。 以下示例显示了如何执行此操作：
[source,java]
----
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
ctx.getEnvironment().setActiveProfiles("development");
ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);
ctx.refresh();
----

此外，您还可以通过spring.profiles.active属性声明性地激活配置文件，该属性可以通过系统环境变量，JVM系统属性，web.xml中的servlet上下文参数或甚至作为JNDI中的条目来指定（请参阅PropertySource Abstraction））。 在集成测试中，可以使用spring-test模块中的@ActiveProfiles批注声明活动配置文件（请参阅具有环境配置文件的上下文配置）。

请注意，配置文件不是“either-or”命题。 您可以一次激活多个配置文件。 以编程方式，您可以为setActiveProfiles（）方法提供多个配置文件名称，该方法接受String ... varargs。 以下示例激活多个配置文件：
[source,java]
----
ctx.getEnvironment().setActiveProfiles("profile1", "profile2");
----

spring.profiles.active属性接受以逗号分隔的列表:
[source,shell]
----
-Dspring.profiles.active="profile1,profile2"
----

===== 默认Profile

表示默认启用的配置文件。 请考虑以下示例：
[source,java]
----
@Configuration
@Profile("default")
public class DefaultDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .build();
    }
}
----

如果没有激活配置文件，则创建dataSource。 您可以将此视为一种为一个或多个bean提供默认定义的方法。 如果启用了任何配置文件，则默认配置文件不适用。

您可以使用环境上的setDefaultProfiles（）或声明性地使用spring.profiles.default属性更改默认配置文件的名称。

===== PropertySource 抽象

Spring的Environment抽象通过可配置的属性源层次结构提供搜索操作。 请考虑以下列表：
[source,java]
----
ApplicationContext ctx = new GenericApplicationContext();
Environment env = ctx.getEnvironment();
boolean containsMyProperty = env.containsProperty("my-property");
System.out.println("Does my environment contain the 'my-property' property? " + containsMyProperty);
----

在前面的代码片段中，我们看到了一种向Spring询问my-property属性是否为当前环境定义的高级方法。 要回答此问题，Environment对象会对一组PropertySource对象执行搜索。 PropertySource是对任何键值对源的简单抽象，Spring的StandardEnvironment配置有两个PropertySource对象 - 一个表示JVM系统属性集(System.getProperties())，另一个表示系统环境变量集（System.getenv()）。

NOTE: 这些默认属性源存在于StandardEnvironment中，用于独立应用程序。 StandardServletEnvironment使用其他默认属性源填充，包括servlet配置和servlet上下文参数。 它可以选择启用JndiPropertySource。 有关详细信息，请参阅javadoc。

具体地说，当您使用StandardEnvironment时，如果在运行时存在my-property系统属性或my-property环境变量，则对env.containsProperty（“my-property”）的调用将返回true。

执行的搜索是分层的。 默认情况下，系统属性优先于环境变量。 因此，如果在调用env.getProperty（“my-property”）期间碰巧在两个位置都设置了my-property属性，则系统属性值“wins”并返回。 请注意，属性值不会合并，而是由前面的条目完全覆盖。

对于常见的StandardServletEnvironment，完整层次结构如下，优先级从高往下：

1. ServletConfig参数（如果适用 - 例如，在DispatcherServlet上下文的情况下）
2. ServletContext参数（web.xml context-param条目）
3. JNDI环境变量（java：comp / env / entries）
4. JVM系统属性（-D命令行参数）
5. JVM系统环境（操作系统环境变量）

最重要的是，整个机制是可配置的。 您可能希望将自定义的属性源集成到此搜索中。 为此，请实现并实例化您自己的PropertySource，并将其添加到当前Environment的PropertySource集合中。 以下示例显示了如何执行此操作：
[source,java]
----
ConfigurableApplicationContext ctx = new GenericApplicationContext();
MutablePropertySources sources = ctx.getEnvironment().getPropertySources();
sources.addFirst(new MyPropertySource());
----

在上面的代码中，MyPropertySource在搜索中添加了最高优先级。 如果它包含my-property属性，则检测并返回该属性，以支持任何其他PropertySource中的任何my-property属性。 MutablePropertySources API公开了许多方法，允许精确操作属性源集。

===== 使用@PropertySource

@PropertySource注释提供了一种方便的声明式机制，用于向Spring的环境添加PropertySource。

给定一个名为app.properties的文件，其中包含键值对testbean.name = myTestBean，以下@Configuration类使用@PropertySource，以便调用testBean.getName（）返回myTestBean：
[source,java]
----
@Configuration
@PropertySource("classpath:/com/myco/app.properties")
public class AppConfig {

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty("testbean.name"));
        return testBean;
    }
}
----

@PropertySource资源位置中存在的任何$ {...}占位符将根据已针对环境注册的属性源集进行解析，如以下示例所示：
[source,java]
----
@Configuration
@PropertySource("classpath:/com/${my.placeholder:default/path}/app.properties")
public class AppConfig {

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty("testbean.name"));
        return testBean;
    }
}
----

假设my.placeholder存在于已注册的其中一个属性源中（例如，系统属性或环境变量），则占位符将解析为相应的值。 如果不是，则/path用作默认值。 如果未指定缺省值且无法解析属性，则抛出IllegalArgumentException。

==== 注册LoadTimeWeaver

Spring使用LoadTimeWeaver在将类加载到Java虚拟机（JVM）时动态转换类。要启用加载时织入，可以将@EnableLoadTimeWeaving添加到其中一个@Configuration类中，如以下示例所示：
[source,java]
----
@Configuration
@EnableLoadTimeWeaving
public class AppConfig {
}
----
xml配置方式:
[source,xml]
----
<beans>
    <context:load-time-weaver/>
</beans>
----

一旦为ApplicationContext配置，该ApplicationContext中的任何bean都可以实现LoadTimeWeaverAware，从而接收对load-time weaver实例的引用。 这与Spring的JPA支持结合使用特别有用，其中JPA类转换可能需要加载时织入。 有关更多详细信息，请参阅LocalContainerEntityManagerFactoryBean javadoc。 有关AspectJ加载时织入的更多信息，请参阅Spring Framework中使用AspectJ的加载时编织。

=== ApplicationContext的其他能力

正如章节介绍中所讨论的，org.springframework.beans.factory包提供了管理和操作bean的基本功能，包括以编程方式。 org.springframework.context包添加了ApplicationContext接口，该接口扩展了BeanFactory接口，此外还扩展了其他接口，以更面向应用程序框架的方式提供其他功能。 许多人以完全声明的方式使用ApplicationContext，甚至不以编程方式创建它，而是依赖于诸如ContextLoader之类的支持类来自动实例化ApplicationContext，作为Java EE Web应用程序的正常启动过程的一部分。

为了以更加面向框架的样式增强BeanFactory功能，上下文包还提供以下功能：
