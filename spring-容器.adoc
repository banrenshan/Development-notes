= spring 容器
:toc: left
:icons: font

== 1. IoC容器和beans

本章介绍Spring Framework实现控制反转（IoC）的原理。 IoC也被称为依赖注入（DI）。他是一个对象通过构造函数、工厂方法的参数、对象被构造函数或者工厂方法实例化后设置属性等方法构建依赖的过程.容器在创建bean时会注入这些依赖关系。这个过程从根本上来说是相反的，因此名为控制反转（IoC），bean本身通过使用类的直接构造或诸如Service Locator模式之类的机制来控制其依赖关系的实例化或位置。

org.springframework.beans和org.springframework.context包是Spring Framework的IoC容器的基础。BeanFactory接口提供了一种能够管理任何类型对象的高级配置机制。 ApplicationContext是BeanFactory的一个子接口，它增加了与Spring的AOP功能的集成、消息资源处理（用于国际化）、事件发布以及Web应用程序上下文（如Web应用程序上下文）。

简而言之，BeanFactory提供了配置框架和基本功能，而ApplicationContext添加了更多的企业特定功能。 ApplicationContext是BeanFactory的一个完整的超集，在本章中专门用于描述Spring的IoC容器。 

在Spring中，构成应用程序主干和由Spring IoC容器管理的对象称为bean。bean是一个由Spring IoC实例化，组装并被容器管理的对象。 否则，bean只是应用程序中众多对象中的一个。 Bean和它们之间的依赖关系反映在容器使用的配置元数据中。

== 2.容器概览

接口org.springframework.context.ApplicationContext表示Spring IoC容器，并负责实例化，配置和组装上述bean。容器通过读取配置元数据获取有关要实例化，配置和组装的对象的指示信息。 配置元数据用可以用XML，Java注释或Java代码表示，它表示组成应用程序的对象以及这些对象之间的相互依赖关系。

Spring提供了几个ApplicationContext接口的实现。 在独立应用程序中，通常创建ClassPathXmlApplicationContext或FileSystemXmlApplicationContext的实例。虽然XML是用于定义配置元数据的传统格式，但您可以通过提供少量的XML配置来指示容器使用Java注释或代码作为元数据格式，以声明的方式支持其他这些元数据格式。

在大多数应用场景中，用户不需要显式的实例化Spring IoC容器的一个或多个实例。例如，在Web应用程序场景中，应用程序的web.xml文件中的简单八行（或多行）样板Web描述符XML通常足以满足。如果您使用的是Spring工具套件Eclipse驱动的开发环境，则只需点击几下鼠标或按键即可轻松创建此样板配置。

=== 配置元数据

配置元数据告诉Spring容器实例化，配置和组装对象。传统上，配置元数据是以简单直观的XML格式提供的，这是本章的大部分内容用来传达Spring IoC容器的关键概念和功能。

有关在Spring容器中使用其他形式的元数据的信息，请参阅：

* <<基于注解配置>>：Spring 2.5引入了对基于注释配置元数据的支持。
* <<基于java代码配置>>：从Spring 3.0开始，Spring JavaConfig项目提供的许多功能成为核心Spring Framework的一部分。 因此，您可以使用Java而不是XML文件来定义应用程序类外部的Bean。 要使用这些新功能，请参阅@Configuration，@Bean，@Import和@DependsOn注释。

基于XML的配置元数据将这些bean配置为顶级<beans/>元素内的<bean/>元素。Java配置通常在@Configuration类中使用@Bean注释的方法。

这些bean定义对应于组成应用程序的实际对象。通常，您可以定义服务层对象，数据访问对象（DAO），Struts Action实例等表示对象，Hibernate SessionFactories等基础结构对象，JMS队列等。通常，不会在容器中配置细粒度的域对象，因为创建和加载域对象通常是DAO和业务逻辑的责任。但是，您可以使用Spring与AspectJ的集成来配置在IoC容器控制之外创建的对象。参考 Using AspectJ to dependency-inject domain objects with Spring

以下示例显示了基于XML的配置元数据的基本结构：
[source,xml]
----


<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="..." class="...">
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <bean id="..." class="...">
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions go here -->

</beans>
----
id属性是一个字符串，用于标识单个bean定义。 class属性定义了bean的类型并使用完全限定的类名。

=== 初始化容器
实例化Spring IoC容器很简单。 提供给ApplicationContext构造函数的位置路径（实际上是资源字符串），它允许容器从各种外部资源（例如本地文件系统，Java CLASSPATH等等）加载配置元数据。
[source,java]
----
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");
----
以下示例显示服务层对象（services.xml）配置文件：
[source,xml]
----


<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- services -->

    <bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">
        <property name="accountDao" ref="accountDao"/>
        <property name="itemDao" ref="itemDao"/>
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions for services go here -->

</beans>
----
以下示例显示数据访问对象daos.xml文件：
[source,xml]
----


<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="accountDao"
        class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">
        <!-- additional collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions for data access objects go here -->

</beans>
----
在前面的示例中，服务层由PetStoreServiceImpl类和两个类型为JpaAccountDao和JpaItemDao的数据访问对象（基于JPA对象/关系映射标准）组成。 属性名称元素引用了JavaBean属性的名称，ref元素引用另一个bean定义的名称。 id和ref元素之间的这种联系表示协作对象之间的依赖关系。

==== 编写基于XML的配置元数据
让bean定义跨越多个XML文件可能很有用。 通常，每个单独的XML配置文件都代表了架构中的逻辑层或模块。您可以使用应用程序上下文构造函数从所有这些XML片段中加载bean定义。这个构造函数有多个资源位置，如前一节所示。 或者，使用一个或多个<import />元素从另一个或多个文件加载bean定义。 例如：
[source,xml]
----
<beans>
    <import resource="services.xml"/>
    <import resource="resources/messageSource.xml"/>
    <import resource="/resources/themeSource.xml"/>

    <bean id="bean1" class="..."/>
    <bean id="bean2" class="..."/>
</beans>
----
在前面的示例中，从三个文件加载外部bean定义：services.xml，messageSource.xml和themeSource.xml。 所有位置路径都与导入的定义文件相关，因此services.xml必须位于与导入文件相同的目录或类路径位置，而messageSource.xml和themeSource.xml必须位于resource位置下面。正如你所看到的，一个前导斜线被忽略，但是*鉴于这些路径是相对的*，最好不要使用斜线。 根据Spring架构，正在导入的文件（包括顶层<beans/>元素）的内容必须是有效的XML bean定义。

NOTE: 可能但不推荐使用相对的“../”路径引用父目录中的文件。这样做会创建对当前应用程序外部的文件的依赖关系。特别是，不建议将此引用用于“classpath：”URL（例如“classpath：../ services.xml”），其中运行时解析过程选择“最近”的类路径根，然后查看其父目录。类路径配置更改可能会导致选择不同的、不正确的目录。

import指令是由bean名称空间本身提供的一项功能。除了普通bean定义以外的其他配置特性可用于由Spring提供的一系列XML名称空间，例如， “context”和“util”命名空间。

=== 使用容器
ApplicationContext是高级工厂的接口，能够维护不同Bean及其依赖项的注册表。 使用方法T getBean（String name，Class <T> requiredType），可以检索bean的实例。

ApplicationContext使您可以读取bean定义并按如下方式访问它们：
[source,java]
----
// create and configure beans
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

// retrieve configured instance
PetStoreService service = context.getBean("petStore", PetStoreService.class);

// use configured instance
List<String> userList = service.getUsernameList();
----
ApplicationContext接口还有其他一些检索bean的方法，但理想情况下，应用程序代码不应该使用它们。 事实上，你的应用程序代码根本不应该调用getBean（）方法，因此完全不依赖于Spring API。 例如，Spring与Web框架的集成为各种Web框架组件（如控制器和JSF管理的Bean）提供了依赖注入，允许您通过元数据（例如自动装配注释）声明对特定Bean的依赖关系。
== Bean概述
Spring IoC容器管理一个或多个bean。 这些bean是使用您提供给容器的配置元数据创建的，例如，以XML <bean/>定义的形式。

在容器本身中，这些bean定义表示为BeanDefinition对象，其中包含以下元数据（以及其他信息）：

* 包限定的类名称：通常是所定义的bean的实际实现类。
* Bean行为配置元素，它说明bean在容器中的行为（范围，生命周期,回调等等）。
* 引用其他bean为其工作的bean; 这些引用也称为协作者或依赖关系。
* 在新创建的对象中设置的其他配置设置，例如，用于管理连接池的Bean的连接数量或池的大小限制。

这个元数据转化为一组构成每个bean定义的属性。

|===
|属性|描述
|class|实例化bean
|name|命名bean
|scope|Bean范围
|constructor arguments|依赖注入
|properties|依赖注入
|autowiring mode|自动装配依赖关系
|lazy-initialization mode|懒惰初始化bean
|initialization method|初始化回调
|destruction method|销毁回调
|===
除了包含有关如何创建特定bean的信息的bean定义之外，ApplicationContext实现还允许用户注册在容器外部创建的现有对象。这是通过getBeanFactory（）方法访问ApplicationContext的BeanFactory来完成的，该方法返回BeanFactory实现的DefaultListableBeanFactory。 DefaultListableBeanFactory通过方法registerSingleton（..）和registerBeanDefinition（..）来支持这种注册。 但是，典型的应用程序只能通过元数据bean定义来定义bean。

NOTE: Bean元数据和手动提供的单例实例需要尽早注册，以便容器在自动装配和其他自省步骤中正确推理它们。虽然重写现有的元数据和现有的单例实例在某种程度上受到支持，但在运行时注册新的Bean（与实时访问工厂同时）并未得到正式支持，并且可能导致并发访问异常和/或bean容器中的状态不一致。

=== 命名bean
每个bean都有一个或多个标识符。 这些标识符在托管bean的容器内必须是唯一的。一个bean通常只有一个标识符，但是如果它需要多个标识符，额外的标识符可以被认为是别名。

在基于XML的配置元数据中，您使用id和/或name属性来指定bean标识符。id属性允许你指定一个id。通常，这些名称是字母数字（'myBean'，'fooService'等），但也可能包含特殊字符。如果要将别名引入到bean中，还可以在name属性中指定它们，并用逗号（，），分号（;）或空格分隔。作为历史记录，在Spring 3.1之前的版本中，id属性被定义为xsd：ID类型，它限制了可能的字符。从3.1开始，它被定义为一个xsd：string类型。 请注意，bean id唯一性仍由容器强制执行，尽管不再由XML解析器执行。

您不需要为bean提供名称或标识。 如果没有显式提供名称或标识，容器为该bean生成一个唯一名称。但是，如果您想通过名称引用该bean，即通过使用ref元素或Service Locator样式查找，您必须提供一个名称。 提供bean名称的原因请参考 inner beans and autowiring collaborators.

NOTE:  在命名bean时使用标准Java约定作为实例名称。也就是说，bean名称以小写字母开头，并且从此驼峰命名基础。 这样的名字的例子是（不带引号）'accountManager'，'accountService'，'userDao'，'loginController'等等。

==== 定义别名
在bean定义本身中，可以通过使用由id属性指定的最多一个名称和name属性中的任意数量的其他名称的组合来为bean提供多个名称。 这些名称可以等同于同一个bean的别名，并且对于某些情况很有用，例如允许应用程序中的每个组件通过使用特定于该组件本身的bean名称来引用公共依赖项。

然而，指定bean实际定义的所有别名并不总是足够的。 有时候需要为其他地方定义的bean引入一个别名。 在大型系统中，通常是这种情况，其中配置分布在每个子系统中，每个子系统都有自己的一组对象定义。 在基于XML的配置元数据中，您可以使用<alias />元素来完成此操作。
[source,xml]
----
<alias name="fromName" alias="toName"/>
----
例如，子系统A的配置元数据可以通过名称subsystemA-dataSource引用数据源。子系统B的配置元数据可以通过名称subsystemB-dataSource引用数据源。在编写使用这两个子系统的主应用程序时，主应用程序通过名称myApp-dataSource引用数据源。要让所有三个名称都引用您添加到MyApp配置元数据中的同一对象，请使用以下别名定义：
[source,xml]
----
<alias name="subsystemA-dataSource" alias="subsystemB-dataSource"/>
<alias name="subsystemA-dataSource" alias="myApp-dataSource" />
----
现在，每个组件和主应用程序都可以通过一个唯一的名称来引用dataSource，并保证不会与任何其他定义冲突（有效地创建名称空间），但它们引用同一个bean。

NOTE: 如果您正在使用Java配置，则可以使用@Bean注释来提供别名，请参阅使用@Bean注释以获取详细信息

=== 实例化bean
bean定义本质上是创建一个或多个对象的配方。容器在被询问时查看命名bean的配方，并使用由该bean定义封装的配置元数据来创建（或获取）实际对象。

如果您使用基于XML的配置元数据，则可以指定要在<bean/>元素的class属性中实例化的对象的类型（或类）。这个类属性在内部是一个BeanDefinition实例的Class属性，通常是强制性的。您可以通过以下两种方式之一使用Class属性：
* 通常，在容器通过反射性调用其构造函数直接创建bean的情况下，指定要构建的bean类，这与使用new运算符的Java代码有些相同。
* 要指定包含将被调用来创建对象的静态工厂方法的实际类，那么容器在类上调用静态工厂方法以创建该Bean的情况较少。 从调用静态工厂方法返回的对象类型可以是完全相同的类或另一个类。

NOTE: 如果要为静态嵌套类配置一个bean定义，则必须使用嵌套类的二进制名称。例如，如果在com.example包中有一个名为Foo的类，并且此Foo类具有一个名为Bar的静态嵌套类，那么bean定义上'class'属性的值将是com.example.Foo$Bar,注意在名称中使用$字符将嵌套类名与外部类名分开。

==== 用构造函数实例化
当您通过构造函数方法创建一个bean时，所有普通类都可以被Spring使用并兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式编码。只需指定bean类就足够了。但是，根据您用于特定bean的IoC类型，您可能需要一个默认（空）构造函数。

Spring IoC容器几乎可以管理任何您想要管理的类; 它不限于管理真正的JavaBeans。 大多数Spring用户更喜欢实际的JavaBeans，它只有一个默认的（无参数）构造函数，以及在容器中的属性之后建模的合适的setter和getter。 您也可以在容器中使用更具异国情调的非Bean风格的类。例如，如果您需要使用绝对不符合JavaBean规范的传统连接池，Spring也可以管理它。
使用基于XML的配置元数据，您可以按如下方式指定您的bean类：
[source,xml]
----
<bean id="exampleBean" class="examples.ExampleBean"/>

<bean name="anotherExample" class="examples.ExampleBeanTwo"/>
----
有关在构造对象后向参数提供参数（如果需要）和设置对象实例属性的机制的详细信息，请参阅注入依赖项。

==== 使用静态工厂方法实例化
在定义一个使用静态工厂方法创建的bean时，可以使用class属性来指定包含静态工厂方法的类和名为factory-method的属性，以指定工厂方法本身的名称。你应该能够调用此方法（使用后面介绍的可选参数）并返回一个活动对象，随后将其视为通过构造函数创建的对象。 这种bean定义的一个用途是在传统代码中调用静态工厂。

以下bean定义指定将通过调用工厂方法来创建该bean。该定义没有指定返回对象的类型（类），而只指定了包含工厂方法的类。在这个例子中，createInstance（）方法必须是一个静态方法。

[source,xml]
----
<bean id="clientService"
    class="examples.ClientService"
    factory-method="createInstance"/>
----
[source,java]
----
public class ClientService {
    private static ClientService clientService = new ClientService();
    private ClientService() {}

    public static ClientService createInstance() {
        return clientService;
    }
}
----
有关在从工厂返回对象之后向工厂方法提供（可选）参数和设置对象实例属性的机制的详细信息，请参阅依赖关系和详细配置。

==== 使用实例工厂方法实例化
与通过静态工厂方法实例化类似，使用实例工厂方法的实例化从容器调用现有bean的非静态方法来创建新的bean。要使用此机制，请将类属性保留为空，并在factory-bean属性中指定当前（或父/祖代）容器中包含要调用以创建对象的实例方法的bean的名称。使用factory-method属性设置工厂方法本身的名称。

[source,xml]
----
<!-- the factory bean, which contains a method called createInstance() -->
<bean id="serviceLocator" class="examples.DefaultServiceLocator">
    <!-- inject any dependencies required by this locator bean -->
</bean>

<!-- the bean to be created via the factory bean -->
<bean id="clientService"
    factory-bean="serviceLocator"
    factory-method="createClientServiceInstance"/>
----

[source,java]
----
public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }
}
----
一个工厂类也可以拥有多个工厂方法，如下所示：
[source,xml]
----
<bean id="serviceLocator" class="examples.DefaultServiceLocator">
    <!-- inject any dependencies required by this locator bean -->
</bean>

<bean id="clientService"
    factory-bean="serviceLocator"
    factory-method="createClientServiceInstance"/>

<bean id="accountService"
    factory-bean="serviceLocator"
    factory-method="createAccountServiceInstance"/>
----
[source,java]
----
public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    private static AccountService accountService = new AccountServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }

    public AccountService createAccountServiceInstance() {
        return accountService;
    }
}
----
这种方法表明，工厂bean本身可以通过依赖注入（DI）进行管理和配置。 详细信息请参阅依赖关系和配置。

== 依赖
下一节将介绍如何从定义许多独立的bean定义到完全实现的应用程序，在这些应用程序中对象协作实现目标。

=== 依赖注入

==== 基于构造函数的依赖注入
基于构造器的DI通过容器调用具有多个参数的构造函数完成，每个参数表示一个依赖项。 调用具有特定参数的静态工厂方法来构造bean和它几乎是等价的。以下示例显示了只能通过构造函数注入进行依赖注入的类。请注意，这个类没有什么特别之处，它是一个POJO，它不依赖于容器特定的接口，基类或注释
[source,java]
----
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on a MovieFinder
    private MovieFinder movieFinder;

    // a constructor so that the Spring container can inject a MovieFinder
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
----
构造函数的参数是通过类型匹配的。如果构造函数中不存在发生歧义的参数列表，构造参数是按顺序注入的，但是，下面的例子：
[source,java]
----
package x.y;

public class Foo {

    public Foo(Bar bar, Baz baz) {
        // ...
    }
}
----
假设Bar和Baz类没有继承关系，就不存在潜在的歧义。因此，以下配置可以正常工作，并且不需要在<constructor-arg />元素中显式指定构造函数参数索引和/或类型。
[source,xml]
----
<beans>
    <bean id="foo" class="x.y.Foo">
        <constructor-arg ref="bar"/>
        <constructor-arg ref="baz"/>
    </bean>

    <bean id="bar" class="x.y.Bar"/>

    <bean id="baz" class="x.y.Baz"/>
</beans>
----
当引用另一个bean时，类型是已知的，并且可以发生匹配（就像前面的例子那样）。当使用简单类型时，例如<value>true</value>，Spring无法确定值的类型，因此无法在没有帮助的情况下按类型进行匹配。 考虑以下类：
[source,java]
----
package examples;

public class ExampleBean {

    // Number of years to calculate the Ultimate Answer
    private int years;

    // The Answer to Life, the Universe, and Everything
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
----
在前面的场景中，如果使用type属性显式指定构造函数参数的类型，则容器可以使用简单类型的类型匹配
[source,xml]
----
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
----
使用index属性明确指定构造函数参数的索引。 例如：
[source,xml]
----
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg index="0" value="7500000"/>
    <constructor-arg index="1" value="42"/>
</bean>
----
除了解决多个简单值的歧义之外，指定索引还解决了构造函数具有两个相同类型参数的含糊问题。请注意，该索引是基于0的。
您也可以使用构造函数参数名称进行值消歧：
[source,xml]
----
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg name="years" value="7500000"/>
    <constructor-arg name="ultimateAnswer" value="42"/>
</bean>
----
请记住，要使这项工作开箱即用，您的代码必须在启用了调试标志的情况下编译，以便Spring可以从构造函数中查找参数名称。 如果你不能用调试标志编译你的代码（或不想），你可以使用@ConstructorProperties JDK注释来显式地命名你的构造函数参数。 示例类将不得不如下所示：
[source,java]
----
package examples;

public class ExampleBean {

    // Fields omitted

    @ConstructorProperties({"years", "ultimateAnswer"})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
----

=== 基于Setter的依赖注入
在调用无参数构造函数或无参数静态工厂方法来实例化bean之后，基于Setter的DI通过调用bean的setter方法来完成。
以下示例显示了一个只能使用纯setter注入进行依赖注入的类。这个类是传统的Java。这是一个POJO，它不依赖于容器特定的接口，基类或注释。
[source,java]
----
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on the MovieFinder
    private MovieFinder movieFinder;

    // a setter method so that the Spring container can inject a MovieFinder
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
----

== 详细的依赖和配置
=== 直接值
<property />元素的value属性将属性或构造函数参数指定为可读的字符串表示形式。Spring的转换服务用于将这些值从String转换为属性或参数的实际类型。
[source,xml]
----
<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <!-- results in a setDriverClassName(String) call -->
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
    <property name="username" value="root"/>
    <property name="password" value="masterkaoli"/>
</bean>
----
以下示例使用p-namespace进行更简洁的XML配置。
[source,xml]
----
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"
        destroy-method="close"
        p:driverClassName="com.mysql.jdbc.Driver"
        p:url="jdbc:mysql://localhost:3306/mydb"
        p:username="root"
        p:password="masterkaoli"/>

</beans>
----
上面的XML虽然更简洁;然而，配置信息在运行时而不是设计时发现错字，除非您在创建bean定义时使用支持自动属性完成的IDE（如IntelliJ IDEA或Spring Tool Suite（STS））。 强烈建议这种IDE帮助。
您还可以将java.util.Properties实例配置为：
[source,xml]
----
<bean id="mappings"
    class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">

    <!-- typed as a java.util.Properties -->
    <property name="properties">
        <value>
            jdbc.driver.className=com.mysql.jdbc.Driver
            jdbc.url=jdbc:mysql://localhost:3306/mydb
        </value>
    </property>
</bean>
----
Spring容器通过使用JavaBeans PropertyEditor机制将<value/>元素内的文本转换为java.util.Properties实例。这是一个很好的捷径，它是Spring团队倾向于在value属性样式上使用嵌套的<value/>元素的几个地方之一。

idref元素只是一种防错的方式，可以将容器中另一个bean的id（字符串值 - 不是引用）传递给<constructor-arg/>或<property />元素。
[source,xml]
----
<bean id="theTargetBean" class="..."/>

<bean id="theClientBean" class="...">
    <property name="targetName">
        <idref bean="theTargetBean"/>
    </property>
</bean>
----
上面的bean定义片段与下面的片段完全等价（在运行时）：
[source,xml]
----
<bean id="theTargetBean" class="..." />

<bean id="client" class="...">
    <property name="targetName" value="theTargetBean"/>
</bean>
----
第一种形式比第二种形式要好，因为使用idref标签允许容器在部署时验证引用的命名bean实际存在。在第二种变体中，不会对传递给客户机bean的targetName属性的值执行验证。当客户端bean实际实例化时，才会发现Typos（最可能致命的结果）。如果客户端bean是prototype bean，则此类型错误和生成的异常可能仅在部署容器后很长时间才能发现。

ref元素是<constructor-arg />或<property />定义元素中的最后一个元素。在这里，您将bean的指定属性的值设置为对容器管理的另一个bean（协作者）的引用。通过<ref />标签的bean属性指定目标bean是最通用的形式，并且允许创建对同一容器或父容器中的任何bean的引用，而不管它是否位于同一个XML文件中。bean属性的值可以与目标bean的id属性相同，或者作为目标bean的name属性中的一个值。
[source,xml]
----
<ref bean="someBean"/>
----
通过parent属性指定目标bean将创建对当前容器的父容器中的bean的引用(他的目标bean必须位于父容器中。)。

[source,xml]
----
<!-- in the parent context -->
<bean id="accountService" class="com.foo.SimpleAccountService">
    <!-- insert dependencies as required as here -->
</bean>
----

[source,xml]
----
<!-- in the child (descendant) context -->
<bean id="accountService" <!-- bean name is the same as the parent bean -->
    class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="target">
        <ref parent="accountService"/> <!-- notice how we refer to the parent bean -->
    </property>
    <!-- insert other configuration and dependencies as required here -->
</bean>
----
=== 内部bean
<property />或<constructor-arg />元素中的<bean />元素定义了一个所谓的内部bean。
[source,xml]
----
<bean id="outer" class="...">
    <!-- instead of using a reference to a target bean, simply define the target bean inline -->
    <property name="target">
        <bean class="com.example.Person"> <!-- this is the inner bean -->
            <property name="name" value="Fiona Apple"/>
            <property name="age" value="25"/>
        </bean>
    </property>
</bean>
----
内部bean定义不需要定义的id或名称; 如果指定，容器不使用这样的值作为标识符。容器在创建时也会忽略范围标志：内部bean始终是匿名的，并且它们始终使用外部bean创建。不可能将内部bean注入到除了封装bean之外的协作bean中，或者独立访问它们。

=== 集合注入
在<list />，<set />，<map />和<props />元素中，分别设置Java集合类型List，Set，Map和Properties的属性和参数。

== 1.6. 自定义bean的本质
=== 1.6.1. 生命周期回调
要与bean的生命周期进行交互，可以实现Spring InitializingBean和DisposableBean接口。 容器为前者调用afterPropertiesSet（），为后者调用destroy（）以允许bean在初始化和销毁bean时执行某些操作。

在内部，Spring框架使用BeanPostProcessor实现来处理它可以找到的任何回调接口并调用适当的方法。 如果您需要自定义功能或其他生命周期行为，Spring不提供开箱即用的功能，您可以自己实现BeanPostProcessor。 有关更多信息，请参阅容器扩展点。

除了初始化和销毁回调，Spring管理的对象还可以实现生命周期接口，以便这些对象可以参与由容器自身生命周期驱动的启动和关闭过程。

本节描述生命周期回调接口。

==== 初始化回调
org.springframework.beans.factory.InitializingBean接口允许bean在bean的所有必要属性已由容器设置后执行初始化工作。 InitializingBean接口指定一个方法：
----
void afterPropertiesSet() throws Exception;
----
建议您不要使用InitializingBean接口，因为它不必要地将代码耦合到Spring。 或者，使用@PostConstruct注释或指定一个POJO初始化方法。 对于基于XML的配置元数据，您可以使用init-method属性来指定具有void无参数签名的方法的名称。 使用Java配置，您可以使用@Bean的initMethod属性，请参阅接收生命周期回调。 例如，以下内容：
----
<bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/>
----

----
public class ExampleBean {

    public void init() {
        // do some initialization work
    }
}
----
和下面的效果完全一样，但不会将代码耦合到Spring。
----
<bean id="exampleInitBean" class="examples.AnotherExampleBean"/>
----
----
public class AnotherExampleBean implements InitializingBean {

    public void afterPropertiesSet() {
        // do some initialization work
    }
}
----

销毁回调
实现org.springframework.beans.factory.DisposableBean接口允许bean在包含它的容器被销毁时获得回调。 DisposableBean接口指定一个方法：
----
void destroy() throws Exception;
----
建议您不要使用DisposableBean回调接口，因为它不必要地将代码耦合到Spring。 或者，使用@PreDestroy注释或指定bean定义支持的通用方法。 使用基于XML的配置元数据时，可以使用<bean />上的destroy-method属性。 使用Java配置，您可以使用@Bean的destroyMethod属性，请参阅接收生命周期回调。 例如，下面的定义：
----
<bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/>
----
----
public class ExampleBean {

    public void cleanup() {
        // do some destruction work (like releasing pooled connections)
    }
}
----
和下面的代码效果相同，但是不会耦合到spring
----
<bean id="exampleInitBean" class="examples.AnotherExampleBean"/>
----
----
public class AnotherExampleBean implements DisposableBean {

    public void destroy() {
        // do some destruction work (like releasing pooled connections)
    }
}
----

==== 默认的初始化和销毁方法
当您编写不使用特定于Spring的InitializingBean和DisposableBean回调接口的初始化和销毁方法回调时，通常会使用诸如init（），initialize（），dispose（）等名称编写方法。 理想情况下，此类生命周期回调方法的名称在项目中标准化，以便所有开发人员使用相同的方法名称并确保一致性。

您可以配置Spring容器以查找命名初始化和销毁每个bean上的回调方法名称。 这意味着作为应用程序开发人员，您可以编写应用程序类并使用称为init（）的初始化回调，而无需为每个bean定义配置init-method =“init”属性。Spring IoC容器在创建bean时（并根据前面描述的标准生命周期回调协议）调用该方法。 此功能还为初始化和销毁方法回调强制执行一致的命名约定。

假设你的初始化回调方法被命名为init（），并且销毁回调方法被命名为destroy（）。 在下面的例子中，你的class将类似于下面的例子。
[source,java]
----
public class DefaultBlogService implements BlogService {

    private BlogDao blogDao;

    public void setBlogDao(BlogDao blogDao) {
        this.blogDao = blogDao;
    }

    // this is (unsurprisingly) the initialization callback method
    public void init() {
        if (this.blogDao == null) {
            throw new IllegalStateException("The [blogDao] property must be set.");
        }
    }
}
----
[source,xml]
----
<beans default-init-method="init">

    <bean id="blogService" class="com.foo.DefaultBlogService">
        <property name="blogDao" ref="blogDao" />
    </bean>

</beans>
----
顶层<beans />元素属性中default-init-method属性的存在导致Spring IoC容器识别出一个名为init的bean方法作为初始化方法回调。 当一个bean被创建和组装时，如果bean类有这样一个方法，它会在适当的时候被调用。

通过在顶级<beans />元素上使用default-destroy-method属性，可以类似地配置destroy方法回调（即在XML中）。

在现有bean类已经具有与惯例不同的回调方法的情况下，可以通过使用<bean />的init-method和destroy-method属性指定方法名称（即XML中的方法名称）来覆盖缺省值 本身。

Spring容器保证了一个配置好的初始化回调函数在bean被提供了所有的依赖关系后立即被调用。 因此初始化回调在原始bean引用上被调用，这意味着AOP拦截器等等还没有被应用到bean。 目标bean首先被完全创建，然后应用带有其拦截器链的AOP代理（例如）。如果目标bean和代理是分别定义的，那么代码甚至可以绕过代理与原始目标bean进行交互。因此，将拦截器应用于init方法会不一致，因为这样会将目标bean的生命周期与代理/拦截器耦合在一起，并在代码直接与原始目标bean交互时留下奇怪的语义。

====结合生命周期机制

从Spring 2.5开始，您有三个控制bean生命周期行为的选项：InitializingBean和DisposableBean回调接口; 自定义init（）和destroy（）方法; 和@PostConstruct和@PreDestroy注释。 你可以结合这些机制来控制给定的bean。

如果为bean配置了多个生命周期机制，并且每个机制都配置了不同的方法名称，那么每个配置的方法都按照下面列出的顺序执行。 但是，如果为这些生命周期机制中的多个生命周期机制配置了相同的方法名称（例如初始化方法的init（）），则该方法将执行一次，如前一部分所述。

为相同的bean配置多种生命周期机制，使用不同的初始化方法，如下所示：

. 用@PostConstruct注解的方法
. 实现InitializingBean接口的afterPropertiesSet（）
. 自定义配置的init（）方法

同样，销毁方法的顺序也是一样的。

==== 启动和关闭回调

生命周期接口为任何具有自己生命周期要求的对象（例如启动和停止一些后台进程）定义基本方法：
----
public interface Lifecycle {

    void start();

    void stop();

    boolean isRunning();
}
----
任何Spring管理的对象都可以实现该接口。然后，当ApplicationContext本身接收到启动和停止信号时，例如 对于运行时的停止/重新启动场景，它会将这些调用级联到在该场景中定义的所有Lifecycle实现。 它通过委派给LifecycleProcessor来完成此操作：
----
public interface LifecycleProcessor extends Lifecycle {

    void onRefresh();

    void onClose();
}
----
请注意，LifecycleProcessor本身就是生命周期接口的扩展。它还添加了两种其他方法来对正在刷新和关闭的上下文作出反应。

请注意，常规的org.springframework.context.Lifecycle接口只是显式启动/停止通知的普通协定，并不意味着在上下文刷新时自动启动。 考虑实施org.springframework.context.SmartLifecycle，而不是对特定bean的自动启动（包括启动阶段）进行细粒度控制。 此外，请注意，停止通知不保证在销毁之前发生：在正常关闭时，所有生命周期bean将在传播通用销毁回调之前首先收到停止通知; 然而，在上下文的生命周期中的热刷新或中止刷新尝试时，只会调用销毁方法。

启动和关闭调用的顺序可能很重要。 如果任何两个对象之间存在“依赖关系”，则依赖方将在其依赖关系之后启动，并且在依赖关系之前停止。 但是，有时直接依赖关系是未知的。 您可能只知道某种类型的对象应该在另一种类型的对象之前启动。 在这些情况下，SmartLifecycle接口定义了另一个选项，即在超级接口Phased上定义的getPhase（）方法。

==== 在非web应用程序中正常关闭Spring IoC容器

如果您在非Web应用程序环境中使用Spring的IoC容器， 例如，在富客户端桌面环境中; 您使用JVM注册了一个关闭钩子。 这样做可以确保正常关闭并在单例bean上调用相关的销毁方法，从而释放所有资源。 当然，您仍然必须正确配置和实施这些销毁回调。

要注册一个关闭挂钩，可以调用ConfigurableApplicationContext接口上声明的registerShutdownHook（）方法：
[source,java]
----
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");

        // add a shutdown hook for the above context...
        ctx.registerShutdownHook();

        // app runs here...

        // main method exits, hook is called prior to the app shutting down...
    }
}
----
